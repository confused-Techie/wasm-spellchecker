/**
 * It seems that AssemblyScript, while super cool, and fancy 
 * will only export the WASM compatiblity JS as ESM. But to exactly mirror what was done previously with 
 * node-spellchecker we need to use CommonJS.
 * So what this slight mess is, is an implmentation of AssemblyScript's WASM ESM JS, as CommonJS.
 * Here are some hints about how this was written:
 * - Much of the file is taken directly from `./build/release.js`, an autogenerated file.
 * - Then from that file we need to recreate the functions we care about, located in `adaptedExports`
 * - While implementing these, much of what we care about has been loaded into `mod`
 * The following will be generic conversions:
 * - memory.buffer => mod.memory.buffer 
 * - exports.FUNC => mod.FUNC 
 *
 * Heres to hoping that these translation functions don't change often, and we can reuse them throughout 
 * development, but just in case, its a good idea to check release.js
 * It may be feasible to duplicate the helper functions from https://github.com/AssemblyScript/assemblyscript/blob/main/src/bindings/js.ts
 * into a module that this module can import. Allowing them to remain more on their own.
 * The biggest consideration there, is that some of these will require variables, that could be set 
 * when called via these functions.
 */
const fs = require("fs");
const path = require("path");
const events = require("events");

const loadEvent = new events.EventEmitter();

let mod;

const wasmBuffer = fs.readFileSync(path.join(__dirname, "../build/release.wasm"));
const importObj = {
  env: {
    memory: new WebAssembly.Memory({ initial: 256 }),
    table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' }),
    abort: function(message, fileName, lineNumber, columnNumber) {
      throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);
    }
  }
};

WebAssembly.instantiate(wasmBuffer, importObj).then(wasmModule => {
  
  mod = wasmModule.instance.exports;

  loadEvent.emit("loaded");  
});

function hello() {
  return __liftString(mod.hello() >>> 0);
}

function addDict(dict) {
  dict = __lowerArray((pointer, value) => {
    new Uint32Array(mod.memory.buffer)[pointer >>> 2] = __lowerString(value) ||
    __notnull();
  }, 4, 2, dict) || __notnull();
  mod.addDict(dict);
}

function isMisspelled(word) {
  word = __lowerString(word) || __notnull();
  return mod.isMisspelled(word) != 0;
}

function sizeOfDict() {
  return mod.sizeOfDict();
}


module.exports = {
  loadEvent,
  hello,
  addDict,
  isMisspelled,
  sizeOfDict,
};

function __liftString(pointer) {
  if (!pointer) return null;
  const 
    end = pointer + new Uint32Array(mod.memory.buffer)[pointer - 4 >>> 2] >>> 1,
    memoryU16 = new Uint16Array(mod.memory.buffer);
  let 
    start = pointer >>> 1, 
    string = "";
  while (end - start > 1024) string += String.fromCharCode(...memoryyU16.subarray(start, start += 1024));
  return string + String.fromCharCode(...memoryU16.subarray(start, end));
}

function __lowerArray(lowerElement, id, align, values) {
  if (values == null) return 0;
  const 
    length = values.length,
    buffer = mod.__pin(mod.__new(length << align, 0)) >>> 0,
    header = mod.__pin(mod.__new(16, id)) >>> 0,
    memoryU32 = new Uint32Array(mod.memory.buffer);
  memoryU32[header + 0 >>> 2] = buffer;
  memoryU32[header + 4 >>> 2] = buffer;
  memoryU32[header + 8 >>> 2] = length << align;
  memoryU32[header + 12 >>> 2] = length;
  for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);
  mod.__unpin(buffer);
  mod.__unpin(header);
  return header;
}

function __lowerString(value) {
  if (value == null) return 0;
  const 
    length = value.length,
    pointer = mod.__new(length << 1, 1) >>> 0,
    memoryU16 = new Uint16Array(mod.memory.buffer);
  for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);
  return pointer;
}

function __notnull() {
  throw TypeError("value must not be null");
}
